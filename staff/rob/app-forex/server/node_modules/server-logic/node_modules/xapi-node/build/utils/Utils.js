"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const Enum_1 = require("../enum/Enum");
class Utils {
    static hideSecretInfo(transaction) {
        return Object.assign(Object.assign({}, transaction), { request: Object.assign(Object.assign({}, transaction.request), { json: 'json contains secret information', arguments: {} }) });
    }
    static parseCustomTag(customTag) {
        if (customTag == null) {
            return { transactionId: null, command: null };
        }
        const customTagData = customTag.split('_');
        if (customTagData.length < 2) {
            return { transactionId: null, command: null };
        }
        const command = customTagData[0];
        const transactionId = customTagData[1];
        return { transactionId, command };
    }
    static getObjectChanges(from, to) {
        const obj = {};
        Object.keys(from).filter(key => from[key] !== to[key]).forEach(key => {
            obj[key] = to[key];
        });
        return obj;
    }
    static formatPosition(t) {
        return {
            close_time: t.close_time,
            closed: t.closed,
            cmd: t.cmd,
            comment: t.comment,
            commission: t.commission,
            customComment: t.customComment,
            digits: t.digits,
            expiration: t.expiration,
            margin_rate: t.margin_rate,
            offset: t.offset,
            open_price: t.open_price,
            open_time: t.open_time,
            order: t.order,
            order2: t.order2,
            position: t.position,
            sl: t.sl,
            storage: t.storage,
            symbol: t.symbol,
            tp: t.tp,
            volume: t.volume,
            position_type: Utils.getPositionType({ cmd: t.cmd, closed: t.closed, close_time: t.close_time })
        };
    }
    ;
    static transactionToJSONString(transaction) {
        try {
            const response = JSON.stringify(transaction.response.json);
            const createdAtUTC = transaction.createdAt.getUTC();
            const sentUTC = transaction.request.sent == null ? null : transaction.request.sent.getUTC();
            const receivedUTC = transaction.response.received == null ? null : transaction.response.received.getUTC();
            return JSON.stringify(Object.assign(Object.assign({}, transaction), { createdAt: transaction.createdAt === null || createdAtUTC === null ? null : createdAtUTC.getTime(), request: {
                    sent: transaction.request.sent === null || sentUTC == null ? null : sentUTC.getTime(),
                    arguments: transaction.command === 'login' ? {} : transaction.request.arguments,
                    json: transaction.command === 'login' ? '"json contains secret information"' : transaction.request.json
                }, response: {
                    status: transaction.response.status,
                    received: transaction.response.received === null || receivedUTC == null ? null : receivedUTC.getTime(),
                    json: response === null || typeof (response) === 'undefined' ? null : ((response.length > 1000) ? '"Too long response #xapi-node"' : response)
                }, transactionPromise: undefined }), null, '\t');
        }
        catch (e) {
            return '{}';
        }
    }
    static getUTCTimestampString() {
        return new Date().getTime().toString();
    }
    static formatNumber(number, length) {
        let result = number.toString();
        return (length - result.length > 0)
            ? '0'.repeat(length - result.length) + result
            : result;
    }
    static getPositionType({ cmd, closed, close_time }) {
        if (cmd === __1.CMD_FIELD.SELL || cmd === __1.CMD_FIELD.BUY) {
            return close_time === null && !closed
                ? Enum_1.PositionType.open
                : Enum_1.PositionType.closed;
        }
        else {
            return cmd === __1.CMD_FIELD.BALANCE || cmd === __1.CMD_FIELD.CREDIT
                ? Enum_1.PositionType.source
                : Enum_1.PositionType.limit;
        }
    }
    static getContractValue({ price, lot, contractSize, currency, currencyProfit }) {
        return lot * contractSize * ((currency === currencyProfit) ? price : 1);
    }
    static getProfit({ openPrice, closePrice, isBuy, lot, contractSize }) {
        return (isBuy ? closePrice - openPrice : openPrice - closePrice) * lot * contractSize;
    }
}
exports.Utils = Utils;
//# sourceMappingURL=Utils.js.map